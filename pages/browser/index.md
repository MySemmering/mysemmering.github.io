# 浏览器

## 1.浏览器缓存

**概念**

- 强缓存和协商缓存是浏览器对网页资源的一种缓存机制。
- 强缓存主要依赖 Cache-Control 和 Expires 这两个字段

**强缓存**

**Cache-control**：http1.1 的产物

- **public：**服务器和客户端都缓存<br/>
- **provate：**只有客户端缓存<br/>
- **max-age：**缓存有效期，单位秒<br/>
- **no-cache：**表示不使用强缓存，而是用协商缓存来判断缓存。客户端缓存内容是否使用缓存则需要经过协商缓存来验证决定。表示不使用 Cache-Control 的缓存控制方式做前置验证，而是使用 Etag 或者 Last-Modified 字段来控制缓存。需要注意的是，no-cache 这个名字有一点误导。设置了 no-cache 之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。<br/>
- **no-store：**禁用缓存。所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存<br/>

**Expires**：http1.0 的产物
expires 用于指定资源过期时间，expires 的一个最大缺陷就是时间读取的是本地时间，如果本地时间做了修改，会影响缓存的判断，可能会导致缓存失效。这也是 cache-control 引入 max-age 的原因之一。

**协商缓存**

1. 协商缓存主要依赖 Last-Modified 和 ETag 这两个字段
2. Last-Modified： If-Modified-Since
3. ETag：If-None-Match

**启发式缓存**

它的计算方式为根据响应头中 2 个时间字段 Date 和 Last-Modified 之间的时间差值,取其值的 10%作为缓存时间周期。

## 2.浏览器输入 URL 发生了什么

1. DNS 解析：浏览器将 URL 中的主机名转换成 IP 地址。

2. 建立 TCP 连接：浏览器将通过 TCP 协议与 Web 服务器建立连接。

3. 发送 HTTP 请求：浏览器将发送 HTTP 请求到 Web 服务器，请求中包含了 URL、请求方式、请求头等信息。

4. 服务器处理请求并返回 HTTP 响应：服务器根据请求内容生成 HTTP 响应并将其发送回浏览器。

5. 浏览器接收 HTTP 响应：浏览器接收到 HTTP 响应后，会对响应进行解析。

6. 构建 DOM 树：浏览器将 HTML 响应转换为 DOM（文档对象模型）树，这是由 HTML 标记表示的页面内容的内存中的表示形式。

7. 构建 CSSOM 树：浏览器将 CSS 响应转换为 CSSOM（CSS 对象模型）树，这是由 CSS 规则表示的页面样式的内存中的表示形式。

8. 创建渲染树：浏览器将 DOM 树和 CSSOM 树组合起来，生成渲染树（Render Tree），渲染树是由浏览器用来渲染页面的树形结构，它包含了 DOM 树中所有可见节点以及这些节点的样式信息。

9. 布局分层：浏览器使用渲染树来执行布局计算，确定每个节点在屏幕上的确切位置和大小。

10. 绘制页面：浏览器遍历渲染树，并将每个节点转换为屏幕上的实际像素，最终将整个页面绘制出来。

11. JavaScript 解析执行：浏览器在遇到 JavaScript 脚本时，会执行脚本并更新 DOM 树和渲染树。

## 3.xss 攻击

**概念**

XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。

**分类**

1. 存储型：
2. 反射型:⽹站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
3. DOM 型: 前端自己取出来参数，然后执行。而不是服务器拼接在 html 中执行

**防御**

1. 对于文本不用 innerHTML 的方式，而是 innerText。
2. 输出转义：对于输出到页面上的数据进行转义，将 HTML 标签、特殊字符等转换为它们对应的实体或字符
3. 设置 cookie 的 HttpOnly 属性，防止 JavaScript 读取 cookie，减少 XSS 攻击的威胁
4. 验证码：对于需要用户输入的敏感操作，如登录、注册等，可以增加验证码的验证机制，防止恶意用户通过 XSS 攻击实现自动化攻击

## 4.CSRF 攻击

**原理是这样的：**

假设你登录了银行网站，并且在浏览器中保存了 cookie。然后你在另一个标签页上打开了一个攻击者的网站，这个网站上有一个看似正常的链接，比如“点击领取优惠券”。但是这个链接实际上是一个隐藏的表单，它向银行网站发送了一个转账请求，把你的钱转给了攻击者。由于你的浏览器还保存着银行网站的 cookie，所以银行网站会认为这个请求是合法的，并执行转账操作。这样，你就被 CSRF 攻击了。

**攻击的时候，可以这么搞:**

搞一些 HTML 标签，如`<img>、<script>、<link>`等，可以加载跨域的资源，并且会自动携带 cookie2。攻击者可以利用这些标签来构造一个隐藏的请求，比如`<img src=“http://bank.com/transfer?amount=1000&to=attacker”>`

**防御**

1. 一些敏感操作带上验证码校验；
2. 进行同源策略检测，比如可以看下 request 请求头的 origin 或者 referer；
3. 后端接口设置有一个请求头，好像叫：Access-Control-Allow-Origin。

## 5.打开一个网页浏览器用了哪些进程

这些进程的功能：

**浏览器进程：**负责用户界面、标签管理、地址栏、书签栏等功能

**GPU 进程：**负责处理GPU相关的任务，如3D绘制或页面合成。（和渲染进程的区别：GPU进程负责处理GPU相关的任务，如3D绘制或页面合成，它可以接收渲染进程发送的图形元素，然后将它们渲染成最终的图像，并发送回渲染进程显示在屏幕上。）

**网络进程：**负责网络资源的请求和下载，如HTML、CSS、JS等文件。

**渲染进程：** 负责将网页内容渲染到屏幕上。每个渲染进程都是独立的沙箱环境，可以运行JavaScript代码和操作DOM树。(和GPU进程的区别：渲染进程负责将网页内容渲染到屏幕上，包括执行JavaScript代码、操作DOM树、计算CSS样式、布局页面元素等任务。)

**插件进程：** 如果用了插件，就会有插件进程

## 6.进程和线程的区别

进程是 cpu 资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是 cpu 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）

## 7.点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？

**点击刷新按钮或者按 F5：** 浏览器直接对本地的缓存文件过期，但是会带上 If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。

**用户按 Ctrl+F5（强制刷新）：** 浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。

**地址栏回车**： 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容

## 8. 常见的浏览器内核比较

**Trident：** 这种浏览器内核是 IE 浏览器用的内核，因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，以前有很多网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 IE 的高市场占有率，微软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等安全问题没有得到解决，加上一些专家学者公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器。

**Gecko：** 这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。

**Presto：** Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快 3 倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。

**Webkit：** Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。

**Blink：** 谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是 KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，Opera 弃用了自己的 Presto 内核，加入 Google 阵营，跟随谷歌一起研发 Blink。

## 9.浏览器垃圾回收机制
https://juejin.cn/post/6941194115392634888#heading-26

## 10.哪些操作会造成内存泄漏？

第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。

第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。

第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。

第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。
